#define TOPIC_DISCOVERY "rt/discovery"
#define TOPIC_DISCOVERY_RESPONSE "rt/discovery/response"

class Device {

  protected:
    bool discoveryStarted = false, discoveryEnded = false;
    bool deviceStatus = true; // ON/OFF status
    string macAddress = "";
    string deviceID = "";
    MQTTClient mqttClient(2048);
    WiFiClient networkClient;

    // Influx connection missing !!!!!


    void checkAndConnectWifi(){
        if (WiFi.status() != WL_CONNECTED) {
            Serial.print(F("Connecting to SSID: "));
            Serial.println(SECRET_SSID);

            WiFi.begin(ssid, pass);
            while (WiFi.status() != WL_CONNECTED) {
              Serial.print(F("."));
              delay(250);
            }
            Serial.print(F("\nConnected to: "));
            Serial.print(WiFi.SSID());
            Serial.print(F(" - My IP: "));
            Serial.println(WiFi.localIP());

            macAddress = WiFi.macAddress() + "-" + deviceID;
        }
    }

    void startMQTTDiscovery(){
        discoveryStarted = true;

        Serial.print(deviceID);
        Serial.println(F(": starting discovery procedure"));

        String description = generateDiscoveryDescriptionMQTT();

        mqttClientAC.publish(TOPIC_DISCOVERY, description);
    }

    void newMessageReceivedMQTT(String &topic, String &payload) {
        Serial.print(deviceID);
        Serial.print(F("Incoming MQTT message: "));
        Serial.print(topic);
        Serial.print(F(" - "));
        Serial.println(payload);

        if(topic == TOPIC_DISCOVERY_RESPONSE && !discoveryEnded)
            handleDiscoveryResponse(payload);
        else
            handleMessageReceivedMQTT(topic, payload);
    }

    void handleDiscoveryResponseAC(String payload){

        DynamicJsonDocument response(2048);
        deserializeJson(response, payload);
        const char *mac = response["mac"];

        if(macAddressAC == mac){
            handleDiscoveryResponseDevice(payload);
            discoveryEnded = true;
            Serial.println(F("AC: discovery phase finished"));
          }
    }

    void void connectToMQTTBroker() {
        if (!mqttClient.connected()) {   // not connected
            Serial.println(deviceID);
            Serial.println(F(": Connecting to MQTT broker..."));

            String lastWillMsg = macAddress + " off";
            mqttClientAC.setWill(TOPIC_DISCOVERY, lastWillMsg.c_str());

            while (!mqttClientAC.connect(MQTT_CLIENTID + deviceID, MQTT_USERNAME, MQTT_PASSWORD)) {
              Serial.print(F("."));
              delay(1000);
            }
            Serial.print(deviceID);
            Serial.println(F(": Connected!"));

            discoveryStarted = false;
            discoveryEnded = false;
        }
      mqttClientAC.subscribe(TOPIC_DISCOVERY_RESPONSE);
      subscribeMQTTTopics();
    }

    void subscribeSingleTopic(String topic){
      if(topic != "" && topic != NULL && topic != "null")
        mqttClient.subscribe(topic);
    }

    bool checkTopics(String topic1, String topic2){
        int posEnd1 = topic1.indexOf('/') + 1;
        int posEnd2 = topic2.indexOf('/') + 1;

        int n1 = std::count(topic1.begin(), topic1.end(), '/');
        int n2 = std::count(topic2.begin(), topic2.end(), '/');

        if(n1 != n2) return false;

        for(int i = 0; i < n1; i++){

            String t1 = topic1.substring(0, posEnd1);
            String t2 = topic2.substring(0, posEnd2);

            topic1.remove(0, posEnd1);
            topic2.remove(0, posEnd2);

            posEnd1 = topic1.indexOf('/') + 1;
            posEnd2 = topic2.indexOf('/') + 1;

            if(t1 != t2 && (t1 != "+/" && t2 != "+/")){
              Serial.print(F("No match found between topics "));
              Serial.print(topic1);
              Serial.print(" ");
              Serial.println(topic2);
              return false;
            }
        }
        return topic1 == topic2;
    }

    virtual void subscribeMQTTTopics() = 0;

    virtual void handleMessageReceivedMQTT(String &topic, String &payload);

    virtual String generateDiscoveryDescriptionMQTT() = 0;

    virtual void updateStatus() = 0;


  public:
    Device(string deviceID){
        this <- deviceID = deviceID;
    }

    void setup(){
        mqttClient.begin(MQTT_BROKERIP, 1883, networkClient);   // setup communication with MQTT broker
        mqttClient.onMessage(newMessageReceivedMQTT);
    }

    void loop(){

        checkAndConnectWifi();

        connectToMQTTBroker();   // connect to MQTT broker (if not already connected)
        mqttClient.loop();       // MQTT client loop

        // Start discovery if the process is not finished
        if(!discoveryStarted && !discoveryEnded)
            startMQTTDiscovery();

        updateStatus();
    }
};
